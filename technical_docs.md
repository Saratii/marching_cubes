Engine:
    This project aims to create a fully deformable world with with much finer detail than any other voxel engine.
    It improves on the technical ideas presented by the ClayBook engine https://www.gdcvault.com/play/1025316/Advanced-Graphics-Techniques-Tutorial-GPU
    The end goal is to have all volumetric data abide by variable viscous fluid dynamics, providing hyper-realistic terrain. 

World Representation:
    The world is represented as volumetric SDF data where each float is a distance to an implicit surface.
    The volumetric data is chunked to allow local world modification and smaller mesh regeneration.
    The Marching Cubes algorithm is used to approximate an isosurface and create a mesh for each chunk out of triangles. 
    Within marching cubes, I used trilinear interpolation to create artifically smooth surfaces from discrete volumetric data.
    The world can be deformed by applying classic SDF logical operations to the SDF sampled data.
    As the player agent moves around the world, new chunks are generated, leading to an effectively infinite sized world like minecraft. 

Chunk Allocation/Deallocation:
    Because the world is infinite in size (all directions) and the volumetric data is already extremely memory intensive, it must be written and read during runtime from SSD storage. 
    Whenever the player agent crosses a chunk boundary, every loaded chunk is validated against a constant distance and chunks that are no longer the radius are deallocated.
    Similarly, the chunks that are now in range that are not loaded are first searched for in the storage data, and if they exist they are loaded into memory.
    If they do not exist they are generated on the spot and written to storage. 
    For efficiency, the storage data is binary to avoid string allocations and have faster write operations. 
    An index file is used to lookup where the chunk data actually is by caching the start byte to avoid having to search the massive data file. 
    Anytime a chunk is deformed, the data is overwritten in storage creating a persistant game state withing having to explictely "save".
    Because chunk operations are expensive, chunk updates require the distance from the last update to be greater than some constant grace area.
    This allows the player to move around a small area that follows the player without any chunk unloading or unloading. 

Backend Bevy:
    This engine uses the popular rust game backend, bevy. This allows much of the boilerplate code to be handled by bevy while still allowing low level attention to detail. 
    Bevy also provides an ECS engine that handles much of the engine state along with parallel data access.

Physics Backend:
    Currently I use rapier to define skeletal collision constraints and solve for collisions. I will likely have to implement something custom when the fluid dynamics simulations are built.

World Generation:
    The entire world is created procedurally.
    The surface data is generated by sampling a fast Fractional Brownian Noise function from the FastNoise2 library built in C++. Even though this is the fastest noise library I could find, chunk generation is still bottlenecked by noise sampling.
    Runtime chunks are generated in parallel and async already but the Mutex locking could be improved. 

- leave no core un-fucked

Drucker-Prager Elastoplasticity - https://math.ucdavis.edu/~jteran/papers/KGPSJT16.pdf, https://www.youtube.com/watch?v=Bqme4WWuIVQ, https://math.ucdavis.edu/~jteran/
visco fluid sim - https://github.com/kotsoft/particle_based_viscoelastic_fluid
MPM (snowball, water, rubber) - https://github.com/Elias-Gu/MPM2D

//reference, delete later
https://80.lv/articles/simulating-a-car-drifting-through-mud-with-a-custom-mpm-solver?utm_source=chatgpt.com
https://www.youtube.com/watch?v=rSKMYc1CQHE